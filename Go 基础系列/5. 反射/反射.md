反射是值在程序运行期对程序本身进行访问和修改的能力



## 变量的内在机制

1. 变量包含  **类型信息和值信息**
2. 类型信息: 是静态的元信息, 是预先定义好的
3. 值信息: 是程序运行过程中动态改变的





## 反射的使用

1. reflect 包封装了反射相关的方法
2. 获取类型信息: reflect.TypeOf 是静态的
3. 获取值信息: reflect.ValueOf 是动态的





## 空接口和反射

- 反射可以在运行是动态获取程序的各种详细信息

- 反射获取 interface 类型信息

  ```go
  // 反射获取 interface 类型信息
  
  func reflect_type(a interface{}) {
     t := reflect.TypeOf(a)
     fmt.Println("类型是: ", t)
     // kind() 获取具体类型. 可以直接去用
     k := t.Kind()
     switch k {
     case reflect.Float64:
        fmt.Println("float64")
     case reflect.String:
        fmt.Println("string")
  
     }
     fmt.Println(k)
     // 
  }
  
  func main() {
     var x float64 = 3.4
     reflect_type(x)
  }
  ```

- 反射获取 interface 值信息

  ```go
  // 反射获取 interface 值信息
  
  func reflect_value(a interface{}) {
     v := reflect.ValueOf(a)   // value 类型
     fmt.Println("类型是: ", v)
     // kind() 获取具体类型. 可以直接去用
     k := v.Kind()
     switch k {
     case reflect.Float64:
        fmt.Println("float64")
        fmt.Println(v.Float())  // 获取值信息
     case reflect.String:
        fmt.Println("string")
  
     }
     fmt.Println(k)
     //
  }
  
  func main() {
     var x float64 = 3.4
     reflect_value(x)
  }
  ```

- 反射修改值信息

  ```go
  package main
  
  import (
     "fmt"
     "reflect"
  )
  
  // 反射修改值
  
  func reflect_set_value(a interface{}) {
     v := reflect.ValueOf(a)  // 值
     k := v.Kind()            // 值的类型
  
     switch k {
     case reflect.Float64:
        // 修改值
        v.SetFloat(6.9)
        fmt.Println("a is ", v.Float())
     case reflect.Ptr: // 判断是否是指针类型
        // Elem() 获取地址指向的值
        v.Elem().SetFloat(9.9)
        fmt.Println("a is ", v.Elem().Float())
        fmt.Println(v.Pointer()) //v.Pointer() 打印地址
     }
  }
  
  func main() {
     var x float64 = 3.4
     // 必须要传指针类型
     //  反射认为下面的是指针类型, 不是float类型
     reflect_set_value(&x)
     fmt.Println("main ", x)
  }
  ```





## 结构体与反射

- 查看类型, 字段和方法

  ```go
  package main
  
  import (
     "fmt"
     "reflect"
  )
  
  type User struct {
     Id   int
     Name string
     Age  int
  }
  
  func (u User) Hello() {
     fmt.Println("hello")
  }
  
  func Poni(o interface{}) {
     t := reflect.TypeOf(o)
     fmt.Println("类型: ", t)         //main.User
     fmt.Println("字符串类型", t.Name()) // User
     // 获取值
     v := reflect.ValueOf(o)
     fmt.Println(v) // {1 za 20}
  
     // 可以获取所有字段
     // 获取结构体字段总个数 t.NumField()
     for i := 0; i < t.NumField(); i++ {
        // 取每一个字段
        f := t.Field(i)
        fmt.Println(f)
        fmt.Printf("%s : %v", f.Name, f.Type)
        // 获取字段的值信息
        // v.Field(i).Interface() 获取字段对应的值
        val := v.Field(i).Interface()
        fmt.Println(val)
  
     }
     fmt.Println("========方法======")
     for i := 0; i < t.NumMethod(); i++ {
        m := t.Method(i)
        fmt.Println(m.Name) //Hello
        fmt.Println(m.Type) // func(main.User)
     }
  }
  
  func main() {
     u := User{Id: 1, Name: "za", Age: 20}
     Poni(u)
  }
  ```

- 查看匿名字段

  ```go
  t.Field(0).Anonymous // true or false
  ```

  ```go
  package main
  
  import (
     "fmt"
     "reflect"
  )
  
  type User struct {
     Id   int
     Name string
     Age  int
  }
  
  // 匿名字段
  type Boy struct {
     User
     Addr string
  }
  
  func main() {
     m := Boy{User{Id: 1, Name: "zs", Age: 12}, "北京"}
     t := reflect.TypeOf(m)
     fmt.Println(t)                  // main.Boy
     // reflect.StructField{Name:"Addr", PkgPath:"", Type:(*reflect.rtype)(0x4a4f40), Tag:"", Offset:0x20, Index:[]int{1}, Anonymous:false}
     // Anonymous: 匿名
     fmt.Printf("%#v\n", t.Field(1)) // addr字段
     fmt.Printf("%#v\n", t.Field(0)) // 第一个字段
     // 值信息
     fmt.Printf("%#v\n", reflect.ValueOf(m).Field(0)) // main.User{Id:1, Name:"zs", Age:12}
  
  }
  ```

- 修改结构体的值

  1. 获取值   2. 找到指针对应的值  3. 判断值的类型  4. 修改值

  ```go
  package main
  
  import (
     "fmt"
     "reflect"
  )
  
  type User struct {
     Id   int
     Name string
     Age  int
  }
  
  // 修改结构体值
  func SetValue(o interface{}) {
     v := reflect.ValueOf(o)
     // 获取指针指向的元素
     v = v.Elem()
     // 去字段
     f := v.FieldByName("Name")
     if f.Kind() == reflect.String {
        f.SetString("ww")
     }
  }
  
  func main() {
     u := User{Id: 1, Name: "zs", Age: 12}
     SetValue(&u)
     fmt.Println("main: ", u)
  }
  ```

- 调用方法

  ```go
  package main
  
  import (
  	"fmt"
  	"reflect"
  )
  
  type User struct {
  	Id   int
  	Name string
  	Age  int
  }
  
  func (u User) Hello(name string) {
  	fmt.Println("Hello ", name)
  }
  
  func main() {
  	u := User{Id: 1, Name: "zs", Age: 12}
  	v := reflect.ValueOf(u) // 值类型
  	// 获取方法
  	m := v.MethodByName("Hello")
  	// 调用方法, 需要传入方法的参数 []Value
  	// 构建call 需要的参数
  	args := []reflect.Value{reflect.ValueOf("6666")}
  	// call 调用方法
  	m.Call(args)
  
  	// 如果方法是无参的情况下,也要构建一个
  	//var args2  []reflect.Value
  	//m.Call(args2)
  
  }
  ```

- 获取字段的tag

  ```go]
  package main
  
  import (
     "fmt"
     "reflect"
  )
  
  type Student struct {
     Name string `json:"name1" db:"name2"`
  }
  
  func main() {
     var s Student
     v := reflect.ValueOf(&s)
     // 取类型
     t := v.Type()
     // 获取字段
     f := t.Elem().Field(0)
     fmt.Println(f.Tag.Get("json"))
     fmt.Println(f.Tag.Get("db"))
  }
  ```







## 反射练习



任务: 解析如下配置文件

- 序列化: 将结构体序列化为配置文件数据并保存到硬盘
- 反序列化: 将配置文件内容反序列化到程序的结构体

配置文件有 server 和 mysql 相关配置











