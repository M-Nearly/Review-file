## Slice 切片  引用类型

- slice 概述

  > 切片本身不是数组，它只想底层的数组

- 切片三要素
  1. 地址 (切片中第一个元素指向的内存空间)
  2. len() 元素个数
  3. cap() 元素容量

- 切片扩容策略 可以通过查看$GOROOT/src/runtime/slice.go源码 
  > 每一次都是上一次的两倍.旧切片的长度小于1024
  > 如果旧切片的长度大于1024,则最终容量就增加原来的1/4


- 创建slice
	1. 直接定义 有可能是只是声明,但是没有内存地址  空 nil 
	2. 基于数组定义切片
	3. make 创建  声明并创建
``` go
1. 直接定义
func main() {
	// 声明切片类型
	var a []string              //声明一个字符串切片
	var b = []int{}             //声明一个整型切片并初始化
	var c = []bool{false, true} //声明一个布尔切片并初始化
	var d = []bool{false, true} //声明一个布尔切片并初始化
	fmt.Println(a)              //[]
	fmt.Println(b)              //[]
	fmt.Println(c)              //[false true]
	fmt.Println(a == nil)       //true
	fmt.Println(b == nil)       //false
	fmt.Println(c == nil)       //false
	// fmt.Println(c == d)   //切片是引用类型，不支持直接比较，只能和nil比较
}

2. 基于数组定义切片
func main() {
	// 基于数组定义切片
	a := [5]int{55, 56, 57, 58, 59}
	b := a[1:4]                     //基于数组a创建切片，包括元素a[1],a[2],a[3]
	fmt.Println(b)                  //[56 57 58]
	fmt.Printf("type of b:%T\n", b) //type of b:[]int
}

元素个数为切片包含的元素个数
容量为当前切片的起始位置到数组的最后一个元素

可以对切片在切片,但是索引不能超过原数组的长度，否则会出现索引越界的错误。


3. 使用make()函数构造切片
make([]T, size, cap)
func main() {
	a := make([]int, 2, 10)
	fmt.Println(a)      //[0 0]
	fmt.Println(len(a)) //2
	fmt.Println(cap(a)) //10
}

```




- 切片方法
	> 可通过go doc 命令查看
	`>go doc  builtin.append`




## Reslice

1. Reslice 按索引取值
2. 索引不可以超过被slice的切片的容量cap()值
3. 索引越界不会导致底层数组的重新分配，而是引发错误



append() 为切片添加元素

1. 可以在slice尾部追加元素
2. 可以将一个slice追加在另一个slice尾部
3. 如果最终长度未超过追加到slice的容量则返回原始slice
4. 如果超过追加到的slice的容量则将重新分配数组并拷贝原始数据
``` go
func main() {
	//append()添加元素和切片扩容 %p 打印内存地址
	var numSlice []int
	for i := 0; i < 10; i++ {
		numSlice = append(numSlice, i)
		fmt.Printf("%v  len:%d  cap:%d  ptr:%p\n", numSlice, len(numSlice), cap(numSlice), numSlice)
	}
}

[0]  len:1  cap:1  ptr:0xc0000a8000
[0 1]  len:2  cap:2  ptr:0xc0000a8040
[0 1 2]  len:3  cap:4  ptr:0xc0000b2020
[0 1 2 3]  len:4  cap:4  ptr:0xc0000b2020
[0 1 2 3 4]  len:5  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5]  len:6  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5 6]  len:7  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5 6 7]  len:8  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5 6 7 8]  len:9  cap:16  ptr:0xc0000b8000
[0 1 2 3 4 5 6 7 8 9]  len:10  cap:16  ptr:0xc0000b8000


// append()函数还支持一次性追加多个元素
var citySlice []string
// 追加一个元素
citySlice = append(citySlice, "北京")
// 追加多个元素
citySlice = append(citySlice, "上海", "广州", "深圳")
// 追加切片
a := []string{"成都", "重庆"}
citySlice = append(citySlice, a...)
fmt.Println(citySlice) //[北京 上海 广州 深圳 成都 重庆]


```




copy()函数复制切片
> copy(destSlice, srcSlice []T)
> srcSlice: 数据来源切片
> destSlice: 目标切片

``` go
func main() {
	// copy()复制切片
	a := []int{1, 2, 3, 4, 5}
	c := make([]int, 5, 5)
	copy(c, a)     //使用copy()函数将切片a中的元素复制到切片c
	fmt.Println(a) //[1 2 3 4 5]
	fmt.Println(c) //[1 2 3 4 5]
	c[0] = 1000
	fmt.Println(a) //[1 2 3 4 5]
	fmt.Println(c) //[1000 2 3 4 5]
}

```


从切片中删除元素 
> 并没有提供特定的删除方法
总结一下就是：要从切片a中删除索引为index的元素，操作方法是a = append(a[:index], a[index+1:]...)
``` go
func main() {
	// 从切片中删除元素
	a := []int{30, 31, 32, 33, 34, 35, 36, 37}
	// 要删除索引为2的元素
	a = append(a[:2], a[3:]...)
	fmt.Println(a) //[30 31 33 34 35 36 37]
}



```
